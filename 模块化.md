# 模块化

摘自网络

模块化的发展情况：  无模块 => CommonJS => AMD规范 =>CMD规范 => ES6模块化

## 无模块

`<script>`标签引入js文件，标签罗列需要注意顺序，被依赖的需要放在前面，否则就会报错。 即简单的将所有的js文件统统放在一起。但是这些文件的顺序还不能出错，比如jquery需要先引入，才能引入jquery插件，才能在其他的文件中使用jquery。缺点很明显：

* 污染全局作用域
* 维护成本高
* 依赖关系不明显

## CommonJS 规范

 该规范最初是用在服务器端的node的，它有四个重要的环境变量为模块化的实现提供支持：`module`、`exports`、`require`、`global`。实际使用时，用`module.exports`定义当前模块对外输出的接口（不推荐直接用`exports`），用`require`加载模块（同步）。

每个模块内部，`module` 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 `module.exports`）是对外的接口。加载某个模块，其实是加载该模块的 `module.exports` 属性

### CommonJS 模块的特点：

- 所有代码都运行在模块作用域，不会污染全局作用域
- 独立性是模块的重要特点就，模块内部最好不与程序的其他部分直接交互
- 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存
- 模块加载的顺序，按照其在代码中出现的顺序

## AMD

CommonJS 规范很好，但是不适用于浏览器环境，于是有了 AMD 和 CMD 两种方案。AMD 全称 Asynchronous Module Definition，即异步模块定义。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。除了和 CommonJS 同步加载方式不同之外，AMD 在模块的定义与引用上也有所不同

## CMD

CMD 全称为 Common Module Definition，是 Sea.js 所推广的一个模块化方案的输出。在 CMD define 的入参中，虽然也支持包含 id, deps 以及 factory 三个参数的形式，但推荐的是接受 factory 一个入参，然后在入参执行时，填入三个参数 require、exports 和 module

## ES6模块化

其设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。而 ES Modules 不是对象，而是通过 `export` 命令显式指定输出的代码

ES Modules 的模块化能力由 `export` 和 `import` 组成，`export` 命令用于规定模块的对外接口，`import` 命令用于输入其他模块提供的功能。我们可以这样定义一个模块：

``` javascript
// 第一种方式
export var firstName = 'Michael';
export var lastName = 'Jackson';
export var year = 1958;

// 第二种方式
var firstName = 'Michael';
var lastName = 'Jackson';
var year = 1958;

export { firstName, lastName, year };
```

然后再这样引入他们：

```javascript
import { firstName, lastName, year } from 'module';
import { firstName as newName } from 'module';
import * as moduleA from 'module';
```

除以上两种命令外，还有一个 `export default` 命令用于指定模块的默认输出（一个模块只能有一个默认输出）。如果使用了 `export default` 语法，在 import 时则可以任意命名。由于 `export default` 命令的本质是将后面的值，赋给 `default` 变量，所以也可以直接将一个值写在 `export default` 之后。当然，引用方式也存在多种：

```javascript
import { default as foo } from 'module';
import foo from 'module';
```

需要注意的是 Modules 会自动采用严格模式，且 import 命令具有提升效果，会提升到整个模块的头部，首先执行。

### 注意模块脚本与普通标准脚本的不同：

 

- 你需要注意本地测试 — 如果你通过本地加载Html 文件 (比如一个 `file://` 路径的文件), 你将会遇到 CORS 错误，因为Javascript 模块安全性需要。你需要通过一个服务器来测试。
- 另请注意，您可能会从模块内部定义的脚本部分获得不同的行为，而不是标准脚本。 这是因为模块自动使用严格模式。
- 加载一个模块脚本时不需要使用 `defer` 属性 (see [`` attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#Attributes)) 模块会自动延迟加载。
- 最后一个但不是不重要，你需要明白模块功能导入到单独的脚本文件的范围 — 他们无法在全局获得。因此，你只能在导入这些功能的脚本文件中使用他们，你也无法通过Javascript console 中获取到他们，比如，在DevTools 中你仍然能够获取到语法错误，但是你可能无法像你想的那样使用一些debug 技术 

## 默认导出 versus 命名

## CommonJs和ES6区别

以下引用阮一峰老师的内容：

（1） CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

- CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
- ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的`import`有点像 Unix 系统的“符号连接”，原始值变了，`import`加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

（2） CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

- 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。
- 编译时加载: ES6 模块不是对象，而是通过 `export` 命令显式指定输出的代码，`import`时采用静态命令的形式。即在`import`时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。

CommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成.



参考：

1. [这一次，我要弄懂javascript的模块化](https://juejin.im/post/6844903636108066830)

2. [JavaScript 模块化方案总结](https://hijiangtao.github.io/2019/08/25/JavaScript-Module-Definitions-and-Webpack-Configurations-Notes/)

